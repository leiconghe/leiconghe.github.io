---
layout: post
title: "C++ STL Queue"
description: "关于C++标准库队列的学习总结"
date: 2023-03-05
tags: C++
color: 'rgb(154,23,255)'
cover: '../assets/test.png'
---

# C++ STL queue

对于任何需要FIFO准则处理的序列来说，queue容器适配器都是最好的选择。

queue的生成方式与stack相同：

```c++
//存放字符串
std::queue<std::string> words;
```

stack<T>、queue<T>这类适配器都默认封装了一个`deque<T>`容器，也可以通过指定第二个模板类型参数来使用其他类型的容器。

```c++
std::queue<std::string,std::list<std::string>> words;	
```

底层容器必须提供这些操作：front()、back()、push_back()、pop_front()、empty()和size()。

## queue操作

* `front()`：返回queue第一个元素的引用。如果queue是常量，则返回一个常引用；如果queue为空，返回值是未定义的。
* `back()`：返回queue中最后一个元素的引用。
* `push(const T& obj)`：在queue的尾部添加一个元素的副本，这是通过调用底层容器的成员函数push_back()来完成的。
* `push(T&& obj)`：以移动的方式在queue的尾部添加元素
* `pop()`:删除queue中的第一个元素
* `size()`：返回queue元素个数
* `empty()`：如果为空，则返回true
* `emplace()`：用传给emplace()的参数调用T的构造函数，在queue的尾部生成对象
* `swap(queue<T> &other_q)`：将当前queue中的元素和参数queue中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板`swap()`来完成相同操作。

### 访问元素

queue没有迭代器，访问元素的唯一方式是遍历容器的内容，并移除访问过的每一个元素：

```c++
std::deque<double> values {1.5,2.5,3.5,4.5};
std::queue<double> numbers(values);
while(!numbers.empty()){
	std::cout<<nunbers.front()<<' ';
    numbers.pop();	//Delete the 1st element
}
```

注意，为了访问全部元素，必须删除它们。如果不想删除容器中的元素，必须将它们复制到另一个容器内。