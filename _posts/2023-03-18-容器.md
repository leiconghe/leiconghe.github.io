---
layout: post
title: "C++11 STL 容器"
description: "关于C++ STL的各种容器的学习总结"
date: 2023-03-18
tags: C++
color: 'rgb(154,133,11)'
cover: '../assets/test.png'
---

# C++11 STL 容器

---

* `array<T,N> `数组容器：表示可以存N个T类型元素，C++本身提供的一种容器。此容器一旦建立，其长度就是固定不变的，只能改变某个元素的值。
* `vector<T>` 向量容器：可以存放T类型元素，是一个长度可变的序列容器。此容器在尾部增加或删除元素效率最高，为O(1)常数阶。但在其它位置插入或删除元素效率较差，时间复杂度为O(n)线性阶，n为元素个数。
* `deque<T> ` 双端队列容器，于vector类似，不过其头部也可以插入和删除元素。但在其它位置插入或删除元素复杂的为O(n)线性阶。
* ` list<T>  `链表容器：长度可变、由T类型元素组成的序列，以双向链表的形式组织元素。任何地方都可以高效插入与删除O(1)，但是访问任意元素要慢，需要沿着链表依次访问移动。
* `forward_list<T>  `正向链表容器：与list类似，不过是由单链表形式组织元素。

## 容器中常见函数成员

序列容器包含一些相同的成员函数，它们功能也是相同的。

### array、vector和deque容器的函数成员：

| 函数成员         | 函数功能                                                     | array<T,N> | vector<T> | deque<T> |
| ---------------- | ------------------------------------------------------------ | ---------- | --------- | -------- |
| `begin()`        | 返回指向容器中第一个元素的迭代器。                           | 是         | 是        | 是       |
| `end()`          | 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 | 是         | 是        | 是       |
| rbegin()         | 返回指向最后一个元素的迭代器。                               | 是         | 是        | 是       |
| rend()           | 返回指向第一个元素所在位置前一个位置的迭代器。               | 是         | 是        | 是       |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是        | 是       |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是        | 是       |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是        | 是       |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是        | 是       |
| assign()         | 用新元素替换原有内容。                                       | -          | 是        | 是       |
| operator=()      | 复制同类型容器的元素，或者用初始化列表替换现有内容。         | 是         | 是        | 是       |
| `size()`         | 返回实际元素个数。                                           | 是         | 是        | 是       |
| max_size()       | 返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数。 | 是         | 是        | 是       |
| capacity()       | 返回当前容量。                                               | -          | 是        | -        |
| `empty()`        | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 | 是         | 是        | 是       |
| `resize()`       | 改变实际元素的个数。                                         | -          | 是        | 是       |
| shrink _to_fit() | 将内存减少到等于当前元素实际所使用的大小。                   | -          | 是        | 是       |
| front()          | 返回第一个元素的引用。                                       | 是         | 是        | 是       |
| back()           | 返回最后一个元素的引用。                                     | 是         | 是        | 是       |
| operator[]()     | 使用索引访问元素。                                           | 是         | 是        | 是       |
| `at()`           | 使用经过边界检査的索引访问元素。                             | 是         | 是        | 是       |
| `push_back()`    | 在序列的尾部添加一个元素。                                   | -          | 是        | 是       |
| `insert()`       | 在指定的位置插入一个或多个元素。                             | -          | 是        | 是       |
| emplace()        | 在指定的位置直接生成一个元素。                               | -          | 是        | 是       |
| emplace_back()   | 在序列尾部生成一个元素。                                     | -          | 是        | 是       |
| `pop_back()`     | 移出序列尾部的元素。                                         | -          | 是        | 是       |
| erase()          | 移出一个元素或一段元素。                                     | -          | 是        | 是       |
| `clear()`        | 移出所有的元素，容器大小变为 0。                             | -          | 是        | 是       |
| swap()           | 交换两个容器的所有元素。                                     | 是         | 是        | 是       |
| data()           | 返回指向容器中第一个元素的指针。                             | 是         | 是        | -        |

### list和forward_list函数成员

| 函数成员        | 函数功能                                                     | list<T> | forward_list<T> |
| --------------- | ------------------------------------------------------------ | ------- | --------------- |
| `begin()`       | 返回指向容器中第一个元素的迭代器。                           | 是      | 是              |
| `end()`         | 返回指向容器最后一个元素所在位置后一个位置的迭代器。         | 是      | 是              |
| rbegin()        | 返回指向最后一个元素的迭代器。                               | 是      | -               |
| rend()          | 返回指向第一个元素所在位置前一个位置的迭代器。               | 是      | -               |
| cbegin()        | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是      | 是              |
| before_begin()  | 返回指向第一个元素前一个位置的迭代器。                       | -       | 是              |
| cbefore_begin() | 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。 | -       | 是              |
| cend()          | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是      | 是              |
| crbegin()       | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是      | -               |
| crend()         | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是      | -               |
| assign()        | 用新元素替换原有内容。                                       | 是      | 是              |
| operator=()     | 复制同类型容器的元素，或者用初始化列表替换现有内容。         | 是      | 是              |
| `size()`        | 返回实际元素个数。                                           | 是      | -               |
| max_size()      | 返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 | 是      | 是              |
| resize()        | 改变实际元素的个数。                                         | 是      | 是              |
| `empty()`       | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 | 是      | 是              |
| `front()`       | 返回容器中第一个元素的引用。                                 | 是      | 是              |
| `back()`        | 返回容器中最后一个元素的引用。                               | 是      | -               |
| `push_back()`   | 在序列的尾部添加一个元素。                                   | 是      | -               |
| `push_front()`  | 在序列的起始位置添加一个元素。                               | 是      | 是              |
| emplace()       | 在指定位置直接生成一个元素。                                 | 是      | -               |
| emplace_after() | 在指定位置的后面直接生成一个元素。                           | -       | 是              |
| emplace_back()  | 在序列尾部生成一个元素。                                     | 是      | -               |
| cmplacc_front() | 在序列的起始位生成一个元索。                                 | 是      | 是              |
| `insert()`      | 在指定的位置插入一个或多个元素。                             | 是      | -               |
| insert_after()  | 在指定位置的后面插入一个或多个元素。                         | -       | 是              |
| pop_back()      | 移除序列尾部的元素。                                         | 是      | -               |
| pop_front()     | 移除序列头部的元素。                                         | 是      | 是              |
| reverse()       | 反转容器中某一段的元素。                                     | 是      | 是              |
| erase()         | 移除指定位置的一个元素或一段元素。                           | 是      | -               |
| erase_after()   | 移除指定位置后面的一个元素或一段元素。                       | -       | 是              |
| remove()        | 移除所有和参数匹配的元素。                                   | 是      | 是              |
| remove_if()     | 移除满足一元函数条件的所有元素。                             | 是      | 是              |
| unique()        | 移除所有连续重复的元素。                                     | 是      | 是              |
| `clear()`       | 移除所有的元素，容器大小变为 0。                             | 是      | 是              |
| swap()          | 交换两个容器的所有元素。                                     | 是      | 是              |
| `sort()`        | 对元素进行排序。                                             | 是      | 是              |
| `merge()`       | 合并两个有序容器。                                           | 是      | 是              |
| splice()        | 移动指定位置前面的所有元素到另一个同类型的 list 中。         | 是      | -               |
| splice_after()  | 移动指定位置后面的所有元素到另一个同类型的 list 中。         | -       | 是              |

## array容器

在使用上，比普通数组更安全，且效率没有变差。注意其大小是固定的。

```c++
#include <array>
using namespace std;	//需要默认使用std命名空间	
```

* 初始化

```c++
std::array<double, 10> values;
std::array<double, 10> values {};	//将所有元素初始化为0
std::array<double, 10> values {0.5,1.0,1.5,2.0};
```

* 访问array容器中单个元素

```c++
values[4] = values[3] + values[2];
values.at(4) = values.at(3) + values.at(2);
//还提供了get<n>模板函数
cout<< get<3>(values);
//data()成员函数,得到指向容器首个元素的指针。
cout<< *(values.data() + 1);
```

## vector容器

```c++
#include <vector>
using namespace std;
```

* 初始化

```c++
std::vector<double> values;	//此时容器未分配空间
values.reserve(20);			//可以增加容器的容量，reserve不会影响已存储元素，但会影响已创建的迭代器

std::vector<int> primes{2,3,5,3,3};
std::vector<double> value(20);	//指定元素个数
std::vector<double> value(20,1.0)	//指定元素个数以及初始默认值
std::vector<int> value1(primes);	//存储其它vector容器
```

```c++
int array[]={1,2,3};
std::vector<int>values(array,array+2);		//values将保存{1，2}
```

* 访问元素

```c++
cout<< values[0];
cout<< values.at(0);
cout<<values.front()<<" "<<values.back();	//第一个和最后一元素
cout<<*(values.data()+2);
```

* 添加元素

```c++
values.push_back(2);
values.emplace_back(2);		//c++11增加的，只是底层机制不同，emplace_back省略了拷贝或移动元素的过程，而push_back会先创建这个元素，再将其拷贝到容器中。
```

* insert()

| 语法格式                           | 用法说明                                                     |
| ---------------------------------- | ------------------------------------------------------------ |
| `iterator insert(pos,elem)`        | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| `iterator insert(pos,n,elem)`      | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| `iterator insert(pos,first,last) ` | 在迭代器 pos 指定的位置之前，插入其他容器（**不仅限于vector**）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
| `iterator insert(pos,initlist)`    | 在迭代器 pos 指定的位置之前，插入初始化列表（**用大括号{}括起来的多个元素，中间有逗号隔开**）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

* emplace()

C++ 11新增加的成员函数，用于在vector容器指定位置之前插入一个新元素。

`iterator emplace (const_iterator pos, args...);`

```c++
std::vector<int> demo{1,2};
demo.emplace(demo.begin(),3);
//打印输出：3 1 2
```

**注意：emplace效率比insert高**，也是因为减少了拷贝或移动的时间。

* 删除元素

| 函数                  | 功能                                                         |
| --------------------- | ------------------------------------------------------------ |
| `pop_back()`          | 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 |
| `erase(pos)`          | 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 |
| swap(beg)、pop_back() | 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。 |
| `erase(beg,end)`      | 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 |
| `remove()`            | 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 |
| `clear()`             | 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。 |

## deque容器

```c++
#include <deque>
using namespace std;
```

* 创建容器

```c++
std::deque<int> d;
std::deque<int> d(10);
std::deque<int> d(10,1);	//初始值1
std::deque<int> d2(d);
//还有可以拷贝数组，与vector一样
```

* 与vector差别

| 函数            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| push_back()     | 在序列的尾部添加一个元素。                                   |
| push_front()    | 在序列的头部添加一个元素。                                   |
| pop_back()      | 移除容器尾部的元素。                                         |
| pop_front()     | 移除容器头部的元素。                                         |
| emplace_back()  | C++ 11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。 |
| emplace_front() | C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。 |

## list容器

```c++
#include <list>
using namespace std;
```

* 创建与初始化

```c++
std::list<int> values;
std::list<int> values(10);
std::list<int> values(10,1);
std::list<int> values1(values);
int a[] = {1,2,3,4};
std::list<int> values(a,a+4);
std::array<int,5>arr{1,2,3,4,5};
std::list<int>values(arr.begin()+2,arr.end());
```

* 主要成员函数

| 成员函数 | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| begin()  | 返回指向容器中第一个元素的双向迭代器。                       |
| end()    | 返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。 |
| empty()  | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 |
| size()   | 返回当前容器实际包含的元素个数。                             |
| emplace_front() | 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 |
| push_front()    | 在容器头部插入一个元素。                                     |
| pop_front()     | 删除容器头部的一个元素。                                     |
| emplace_back()  | 在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。 |
| push_back()     | 在容器尾部插入一个元素。                                     |
| pop_back()      | 删除容器尾部的一个元素。                                     |
| emplace()       | 在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。 |
| insert()        | 在容器中的指定位置插入元素。                                 |
| erase()         | 删除容器中一个或某区域内的元素。                             |
| swap()          | 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 |
| resize()        | 调整容器的大小。                                             |
| clear()         | 删除容器存储的所有元素。                                     |
| splice()        | 将一个 list 容器中的元素插入到另一个容器的指定位置。         |
| `remove(val)`   | 删除容器中所有等于 val 的元素。                              |
| remove_if()     | 删除容器中满足条件的元素。                                   |
| unique()        | 删除容器中相邻的重复元素，只保留一个。                       |
| merge()         | 合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。 |
| sort()          | 通过更改容器中元素的位置，将它们进行排序。                   |
| reverse()       | 反转容器中元素的顺序。                                       |

* 迭代器示例

```c++
std::list<char> values{'h','t','t','p',':','/','/','c','.','b','i','a','n','c','h','e','n','g','.','n','e','t'};
std::list<char>::iterator begin = values.begin();
std::list<char>::iterator end = values.end();
values.insert(begin,'1');
while(begin != end){
    cout<< *begin;
    ++begin;
}
```

* 访问list存储的内容，只能使用list容器的迭代器。

```c++
std::list<int> values {1,2,3,4,4};
auto it = values.begin();
while(it != values.end()){
	std::cout<<*it<<" ";
	++it;
}
```

* 插入元素
  * push_front()
  * push_back()
  * emplace_front()
  * emplace_back()
  * emplace()
  * insert():用法同vector的insert用法，共4种。
  * splice():将其它list存储的元素添加到当前list

```c++
std::list<int> values{1,2,3};
values.push_front(0);	//0,1,2,3
values.emplace_back(4);	//0,1,2,3,4
values.emplace(values.end(),6);	//0,1,2,3,4,6
```

```c++
std::list<int> values{0,1,2,3,4,5,6,7,7,8};
std::list<int>::iterator it = values.begin();
int i = 5;
while(i != 0){
    it++;			//特别注意，list的双向迭代器只支持自增与自减
    i--;
}
values.insert(it,18);
```

* 删除list元素

相比前面，多了一个：unique(),删除容器中相邻的重复元素，只保留一份。

* erase()：根据位置删除

  `iterator erase (iterator position);`

  `iterator erase (iterator first, iterator last);`

  ```
  auto del = values.begin();
  ++del;
  values.erase(del);	//删除第2个元素
  ```

* remove()：根据元素的值删除

  ```c++
  list<char> values{'a','b','c'};
  values.remove('c');
  ```


* unique()：去除重复值，同时可以自定义删除规则

  `void unique()`

  `void unique(BinaryPredicate)`:传入一个二元谓词函数，可以使用正则表达式

  ```c++
  std::list<int> mylist{ 15, 36, 7, 17, 20, 39, 4, 1 };
      //删除 mylist 容器中能够使 lamba 表达式成立的所有元素。
  mylist.remove_if([](int value) {return (value < 10); }); //{15 36 17 20 39}
  
  ```

## 关联式容器

STL提供了4种关联式容器：map、set、multimap、multiset。底层采用红黑树。

| 容器名称 | 头文件       | 特点                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
| map      | `<map>`      | 各个元素的键必须是唯一的(即不可重复)，会根据键值大小，默认升序排序（调用std::less<T>) |
| set      | `<set>`      | 元素键和值完全相同，且各个元素不可重复，默认升序排序         |
| multimap | `<multimap>` | 元素的键可以重复                                             |
| multiset | `<multiset>` | 可以重复                                                     |

STL同样提供了哈希容器，底层采用哈希表，即:unordered_map、unordered_set、unordered_multimap、unordered_multiset。

```c++
#include <iostream>
#include <map>
#include <string>
using namespace std;
map<string,string> mymap;
mymap["http://xxxxx.com"] = "网站";
//……
for(map<string,string>::iterator it = mymap.begin() ; it != mymap.end; ++it){
    //输出各个元素的键和值
    cout<<it->first<< " => " << it->second <<endl;
}
```

### map

#### pair类模板

C++ STL提供了pair类模板，其专门用来将2个普通元素`first`和`second`创建成一个新元素`<first,second>`。

> pair类模板定义在`<utility>`头文件中。

* 初始化

```c++
#include <utility>
#include <string>
pair <string,double> pair1;	
pair <string,string> pair2("STL教程","http://c.baincheng.net");
//或通用的方式
pair <string,string> pair2 = {"STL教程","http://c.baincheng.net"};
pair <string,string> pair3(pair2);	//拷贝构造函数
//移动构造函数
pair <string,string> pair4(make_pair("C++教程","http://www.c++.com"));
//或者
pair <string,string> pair4 = make_pair("C++教程","http://www.c++.com");
pair <string,string> pair5(string("Python教程"),string("http://python.com"));	//使用右值引用参数，创建pair对象
```

除此以外，还允许手动为pair对象赋值：

```c++
pair1.first = "Java教程";
pair2.second = "www.java.com";
std::cout<< pair1.first <<" "<< pair.second;
```

* 比较

pair对象重载了<、<=、>、>=、==、!=这6个运算符，其运算规则为：

> 对应比较的2个pair对象，先比较pair.first，若相等，则再比较pair.second。

* 交换

需要指出，pair类提供一个swap()成员函数，能够互换两个pair对象的键值对：

```c++
pari1.swap(pair2);
```



#### map容器

* 初始化

```c++
std::map<std::string, int>myMap;
std::map<std::string, int>myMap{{"c语言教程",10},{"STL教程",20}};
std::map<std::string, int>myMap{std::make_pair("c语言教程",10),std::make_pair("STL教程",20)};
std::map<std::string, int>newMap(myMap);	//拷贝构造函数创建newMap容器
std::map<std::string, int>newMap(++myMap.begin(),myMap.end());
//指定排序规则，令其降序排序
std::map<std::string, int,std::greater<std::string>> myMap;
```

* 成员函数

  与前面容器的成员函数基本一致，只不过是函数形参变成了key。

```c++
std::map<std::string, int> valueMap;
valueMap.emplace("It之家",10);
valueMap.insert("Java教程",20);
std::cout<<valueMap.size()<<std::endl;
for(auto i = valueMap.begin(); i != valueMap.end(); ++i){
    cout<<i->first << " " << i->second<<std::endl;
}
```

* 迭代器

  > 注意，多了一个find函数

| find(key) | 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| --------- | ------------------------------------------------------------ |

```c++
auto iter = valueMap.find("Java教程");	//查找键为“Java教程”的键值对
//从iter开始，遍历map容器
for(;iter != valueMap.end(); ++iter){
    std::cout<<iter->first() << " " <<iter->second << std::endl;
}
```

#### 从Map中获取键

> 注意：multimap不支持at()成员方法，也没有重载[]运算符。愿意就是指定的键可能对应多个键值对。

* map类对`[]`进行了重载

  ```c++
  int cValue = valueMap["Java教程"];
  ```

  也可以借助这种方式进行添加或修改内容：

  ```c++
  std::map<std::string, std::string> myMap{"C语言","http://adfa"};
  myMap["Python教程"] = "http://python.com";	//添加
  myMap["C语言"] = "http://c.com";	//修改
  ```

* 使用`.at()`方式

  ```c++
  cout<< myMap.at("C语言");
  ```

* 选用`find()`函数：需要注意的是，该方式返回的是迭代器，不是对应键的值。

  multimap返回的是对应键值的双向迭代器。

#### Map插入元素

* map类对象对`[]`进行了重载，因此不仅可以用来访问元素，还可以进行添加与修改。

```c++
std::map<string,string> myMap {{"STL教程"，"http://c.sdfd"}};
myMap["STL教程"] = "http://c.biancheng.net";	//修改
myMap["Python教程"] = "http://python.com";	//添加
```

* 使用`insert()`方法插入键值对

```c++
//创建一个pair
std::pair<string,string> STL = {{"STL教程","http://c.biancheng.net/stl"}};
std::map<string,string> myMap;
auto ret = myMap.insert(STL);	//返回的是pair对象，成功ret即为<插入对象的pair，1>,失败：<pair,0>

ret = myMap.insert({"C语言","http://cprogram.com"});	//右值引用方式传递
```
指定位置插入：

```c++
auto iter = myMap.begin();
myMap.insert(iter,STL);	//上面的插入方式都支持
```

一次插入多个键值对：`void insert({val1,val2,...})

```c++
myMap.insert({{"C语言","http://cprogram.com"},{"STL教程","http://c.biancheng.net/stl"}});
```

* `emplace()`方法

相比insert()更简单，此方法可以自行构建出键值对。

```c++
auto myMap.emplace("Java"，"http://java.com"); //返回值类型与insert一致
```

* `emplace_hint()`方法

相比emplace，此方法需要指定迭代器作为第一个参数，即**指定插入位置**。返回值类型也不再是pair类型，而是迭代器。

```c++
auto iter = myMap.emplace_hint(myMap.begin(),"STL教程","http://c.biancheng.net/stl");
```

### Set

需要注意一点，由于set集合key就是value，由于key不可变，因此我们不能通过set的迭代器进行修改其元素值，其迭代器是常量迭代器。

## 无序容器

> 特点：底层是哈希表实现无序容器，当有数据存储有冲突时，选用"链地址法"。即哈希表不再存放value，而是存放链表指针。
>
> * 键值对无序
> * 查找效率高，平均时间复杂度O(1)。但遍历迭代效率低。

当涉及到大量遍历容器操作时，选用关联式容器；当更多操作是通过键值对查找对应值时，选用无序容器。

* unordered_map、unordered_set、unordered_multimap、unordered_multiset。

### unordered_set

与set不同，不需要排序，底层为hash表。特点如下：

* 不再以键值对形式存储，而是直接存储数据的值
* 容器内部存储的各个元素都不相等，且不能被修改
* 不会对内部存储的数据进行排序



```c++
unordered_set<int> set1;	//空set
unordered_set<int> set2(set1);	//拷贝构造
unordered_set<int> set3(set1.begin(),set1.end());	//迭代器构造
unordered_set<int> set4(arr,arr+5);		//数组作为初值
unordered_set<int> set5{1,2,12,43};
```

* 常用函数

```c++
set.empty();
set.find(val);		//返回迭代器；失败返回end(),因此判断是否查找成功采用格式如下：
		if(set.find(3) != set.end())
set.count(val);		//返回val出现次数
set.insert();		//(val)、(迭代器，val)、({list})
set.emplace();		//效率更高
set.earse();		//(val)、(set.find(val))、(迭代器)
set.clear();
set.rehash(bucker_num)	//设置篮子数m
```

### unordered_map

* 查询单个key的效率比map高，但是查询某一范围的key比map效率低

* 存储元素没有顺序，只是根据key的哈希值，将元素存储在指定位置。因此根据key查询单个value时非常高效，平均可以在常数时间内完成。

* 可以使用"[]"操作符来访问key对应的value值。

* 判断为空条件与unordered_set一样：

  ```c++
  auto it = umap.find(key);
  if(it != umap.end()){}
  ```


#### 删除元素：erase()和clear()

* 删除迭代器指向的键值对：

  ```c++
  iterator erase(const_iterator position);
  //示例
  auto ret = umap.erase(umap.begin());
  ```

* 根据键删除对应键值对

  ```c++
  size_type erase(const key_type& k);
  //示例
  int delNum = umap.erase("Python教程")；
  ```

* 删除指定范围的键值对：

  ```c++
  iterator erase(const_iterator first, const_iterator last);
  //示例
  unordered_map<string,string>::iterator first = umap.begin();
  unordered_map<string,string>::iterator second = umap.end();
  auto ret = umap.erase(first,second);
  ```

* 清除所有元素

  ```c++
  void clear();
  umap.clear();
  ```

  

### Hash函数

unordered_map()提供的hash<key>哈希函数，只适用于基本数据类型(包括string),不适用于自定义的结构体或者类。

同样，对应的比较函数equal_to也不适用于自定义类型，需要自己设计适用于该类型的哈希函数和比较函数，并显示传递给Hash参数和Pred参数。

##### 举例

```c++
class Person {
public:
	Person(string name, int age) : name(name),age(age){};
    string getName() const;
    string getAge() const;
private:
    string name;
    int age;
}
string Person::getName() const {
    return this->name;
}
string Person::getAge() const {
    return this->age;
}
```

这个是类的例子，在网上看到关于自定义结构体类型，重构哈希函数与重载==号，使用的也是struct，也就是把class替换成了struct，其它不变。

**重新构建哈希函数：**

* 自定义哈希函数
* 重载()运算符，其参数必须是const类型，且该方法必须以const修饰

```c++
class hash_fun {
public:
    int operator()(const Person &A) const {
        //这里只使用一个人的年龄和姓名进行哈希映射
        //第一个()是实例化一个hash<int>类对象
        //第二个()是像函数一样使用该对象
        return std::hash<int>()(A.getAge()^ std::hash<int>()(A.getName());	//异或一下
        //还有第二种写法，c++11开始支持
        //{}表示列表初始化
        return std::hash<int>{}(A.getAge()) ^ std::hash<int>{}(A.getName());
    }
};
```

* 将hash_fun作为参数传递给该容器模板类中的Pred参数：

  ```c++
  std::unordered_set<Preson,hash_fun> myset;
  ```

  

**自定义比较规则：**

* 我们还需要继续构建比较规则，重载==运算符

  默认的std::equal_to<key>比较规则，其本质是一个模板类，底层实现如下：

```c++
template<class T>
class equal_to {
public:
    bool operator()(const T& _Left, const &T _Right) {
        return (_Left == _Right);
    }
}
```

因此，==仅适用于可以直接使用`==`进行比较的数据类型==。

1) 方式1：重载==运算符:写到上面的hash_fun类里面。

```c++
bool operator==(const Person &A, const Person &B) {
	return (A.getAge() == B.getAge());	
}
```

注意：两个参数都需要const修饰！！！。

* 使用实例：

  ```c++
  std::unordered_map<Person,hash_fun> myset{{"张三","18"},{"李四","30"},{"李四","20"}};
  ```

最终容器只会储存{"张三","18"}、{"李四","20"}。

2. 方式2：自定义比较规则，完全舍弃std::equal_to<key>，以函数对象类方式自定义比较规则。

```c++
class mycmp {
public:
    bool operator()(const Person &A, const Person &B) {
        return (A.getName() == B.getName()) && (A.getAge() == B.getAge());
    }
}
```

使用：

```c++
std::unordered_set<Person, hash_fun, mycmp> myset{{"张三","18"},{"张三","18"},{"李四","30"}};
```

同样，最终只会存储：{"张三","18"},{"李四","30"}

# STL容器适配器

---

## stack

默认基于deque容器，满足要求的基础容器有：vector、deque、list。

基础容器需要包含以下成员函数：

* empty()
* size()
* back()
* push_back()
* pop_back()

### 构建方法

* 使用List容器构建

  ```c++
  std::stack<std::string, std::list<int>> val_stack;
  ```

  可以用一个基础容器来初始化stack，需要保证该容器与stack底层容器一致

  ```c++
  std::list<int> values {1,2,3};
  std::stack<int, std::list<int>> my_stack (values);
  ```

* 直接构建

  ```c++
  std::stack<string> my_stack;
  ```

* 使用另一个stack构建

  ```c++
  std::stack<int, std::list<int>> my_stack1 (my_stack);
  ```

### 成员函数

* empty()
* size()
* top()
* push(const T& val):先复制元素，再将val副本压入栈顶，底层调用push_back()函数
* push(T&& obj)：以移动的方式压入栈顶
* pop()
* emplace(arg...):可以接收多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素
* swap(stack<T>& other_stack):将两个stack进行元素互换。注意：两个栈的底层容器必须相同

## queue

默认基于deque容器，满足要求的基础容器有：deque、list。

基础容器需要包含以下成员函数：

* empty()
* size()
* front()
* back()
* push_back()
* pop_front()

### 成员函数

* empty()
* size()
* front()
* back()
* push(const T& val)
* emplace():在queue的尾部直接添加元素
* push(T&& obj)
* pop
* swap(queue<T>& other_queue)

## priority_queue

默认基于vector实现，满足条件的基础容器有：vector、deque。

基础容器需要包含以下成员函数：

* empty()
* size()
* front()
* push_back()
* pop_back()

### 说明

与queue的不同之处在于，priority_queue原则是“队尾进，优先级最大的先出”。

priority_queue又被称为优先级队列，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队头；同样，队首出队以后，它会再次找到优先级最高的元素，并将其移动到队首。

### 初始化

```c++
std::priority_queue<int> my_queue;
std::priority_queue<int, std::deque<int>, std::greater<int>> my_queue(values,values+4);
//指定容器类型与排序规则，并指定初始化对应范围的数据。values可以是普通数组，也可以是指定的容器。
```



# STL 标准库

---

## sort()

sort()函数本质是一个模板函数，专用于对容器或普通数组中指定的范围内元素进行排序。默认升序排序规则。

> sort()是基于快速排序实现的

* sort()仅适用于普通数组和支持随机迭代器的容器：array、vector、deque这三种。
* 引用文件：`#include <algorithm>`

### 指定排序方式

```c++
//升序
sort(begin,end,std::less<T>());
//降序
sort(begin,end,std::greater<T>());
```

* 注意范围，[begin,end)，不包含右边

### 自定义排序规则

```c++
bool cmp(const vector<int>& a,const vector<int>& b) {
    if(a[0] == b[0]) return a[1] < b[1];	//vector第1位相等，则判断第二位
    else return a[0] < b[0];
}
vector<vector<int>> people;
sort(people.begin(),people.end());
```

* **注意，返回值类型为bool，`a>b为降序，a<b为升序`。**

## stable_sort()

相当于sort()的升级版，语法一致，只不过stable_sort()可以保证**不改变相等元素的相对位置**。
