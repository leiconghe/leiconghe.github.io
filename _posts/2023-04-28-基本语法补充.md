---
layout: post
title: "C++基础语法补充"
description: "关于C++基本语法的补充与总结"
date: 2023-04-27
tags: C++
color: 'rgb(154,133,255)'
cover: '../assets/test.png'
---



## 1. 函数重载

普通的C语言中，要求函数名必须是唯一的，如果想定义一个函数实现整数、长整型数和双精度数的二次方时，用C语言就必须定义3个函数名不同的函数：

```c
Isquare(int i);		//求整数的二次方
Lsquare(long l);	//求长整型数的二次方
Dsquare(double d);	//求双精度型数的二次方
```

而C++/Java支持函数的重载，即同一函数名，支持不同类型的参数：

```c++
int square(int i);
long square(long l);
double square(double d);
```

函数重载就是:当两个或两个以上函数公用一个函数名时，成为函数重载，被重载的函数就是重载函数。

说明：

* 调用重载函数时，函数返回值类型不在参数匹配检查之列，因此当两个函数参数相同，只有返回值类型不同时，不允许重载。

* 函数重载与带默认值的函数一起使用时，有可能引起二义性：

  ```c++
  void Drawcircle(int r = 0, int x = 0, int y = 0);
  void Drawcircle(int r);
  ```

* 在函数调用时，如果给出的实参和形参类型不匹配，C++编译器会自动做类型转换，此时可能会产生不可识别的错误。

## 2. 内联函数

在函数说明前冠以“inline”说明的函数就是内联函数，此举是为了减少程序调用函数时的系统开销，提高程序执行效率。内联函数在C++编译器编译时，会自动将内联函数代码插入到调用该函数的代码处。

我们知道，在程序执行过程中调用函数时，会先将一些状态信息（如现场和返回地址等）存到栈中，同时转到函数代码处去执行函数体，这些参数的保存与传递过程需要时间和空间的开销，使得程序执行效率降低。

```c++
inline int add(int a, int b){
	return a + b;
}
```

说明：

* 内联函数在第1次调用之前必须进行完整的定义
* 内联函数体一般不能含有复杂的控制语句，如for、switch等
* 内联函数代码尽量小，一般1~5行语句，尽量是使用频繁的函数，否则意义不大
* 与宏定义#define类似，但是消除了宏定义的不安全性。

## 3. 作用域运算符“::”

由于局部变量优先级高于全局变量（即名字相同的两个变量，局部声明的变量优先使用），“::”作用域运算符可以实现在局部变量的作用域内使用同名的全局变量。

```c++
int avar;
int func(){
    int avar();
    avar = 10;		//给局部变量avar赋值
    ::avar = 15;	//给全局变量avar赋值
    return ::avar;	//返回全局变量avar的值
}
```

## 4. 强制类型转换

1. C语言格式

   ```c
   int i = 10;
   double x = (double)i;
   ```

2. 建议格式

   ```c++
   int i = 10;
   double x = double(i);
   ```

3. C++11

   ```c++
   static_cast<long> (value);
   ```

## 5. 运算符new和delete

**指针变量名 = new 类型；**

**指针变量名 = new 类型（初值）；**

```c++
int *ptr;
ptr = new int;
int *pi = new int[10];	//动态分配数组内存空间

int i = 3;
int *pi = new int[i][3][2];		//多维数组，只有第1维可变

//简单分配内存并赋初值
int *p = new int(24);
```

**delete 指针变量名**

**delete []指针变量名**

```
delete ptr;
//释放动态分配的数组存储区
delete []pi;
```

## 6. 类

格式：

**class 类名{**

​	**[private:]**

​		**私有数据成员和私有函数**

​	**public:**

​		**公有数据成员和共有函数**

**}；**

* **注意：在类的声明中不能给数据成员赋初值。**

### 成员函数定义

定义方式1：（考虑到c/c++有.cpp和.h两种文件，而Java只有.java，因此可以分开声明类以及实现类到不同文件里）

* 优点：使类的声明简单明了，便于阅读
* 有助于把类的接口和类的实现相分离，隐藏了执行的细节。

**返回值类型 类名 :: 成员函数名（参数表）**

**{**

​	**函数体**

**}**

```c++
class Point{
    public:
    	void setPoint(int , int );		//设置成员函数的函数原型
    	void getx();
    	void gety();
    private:
    	int x,y;
};

void Point::setPoint(int a, int b){		//在类外定义成员函数
    x = a;
    y = b;
}
int Point::getx(){
    return x;
}
int Point::gety(){
    return y;
}
```

如果函数名前没有类名，或既无类名，有没有作用域运算符“::”，则该函数不属于任何类，不是成员函数，而是普通函数：

```c++
::getx(){

}
gety(){

}
```

* 在类声明中，成员函数的原型的参数可以不说明参数的名字，仅说明参数类型即可。

定义方式2：

将成员函数直接定义到类内部。

```c++
class Point{
    public :
    	void setPoint(int a, int b){
            x = a;
            y = b;
        }
    	int getx(){
            return x;
        }
    	int gety(){
            return y;
        }
    private:
    	int x,y;
}
```

定义方式3：

在类声明中只给出成员函数原型，而成员函数定义到类外，但是在类内函数原型声明前或在类外定义成员函数前冠以关键字"inline",以此显式地说明这是一个内联函数。

```c++
class Point{
    public:
    	inline void setPoint(int , int );		//设置成员函数的函数原型
    	inline void getx();
    	inline void gety();
    private:
    	int x,y;
};

inline void Point::setPoint(int a, int b){		//在类外定义成员函数
    x = a;
    y = b;
}
inline int Point::getx(){
    return x;
}
inline int Point::gety(){
    return y;
}
```

### 对象的定义

1. 声明类的同时，直接定义对象

   ```c++
   class Point{
       public:
       	void setPoint(int , int );		//设置成员函数的函数原型
       	void getx();
       	void gety();
       private:
       	int x,y;
   }op1,op2;
   ```

2. 声明了类后，在使用类时定义

   **类名 对象名1，对象名2，……；**

   ```c++
   Point op1,op2;
   ```

### const修饰成员函数

```c++
class Socket{
public:
	typedef unsigned short socket_port_t;
    socket_port_t LocalPort(void) const{
        ++readCount;
        return _port;
    }
private:
    socket_port_t _port;
    mutable int _readCount;
}
```

使用const修饰的成员函数不能修改类的成员变量，如成员_port，并且只能调用成员类对象const函数。但有个例外，就是mutable修饰的成员变量可以在const修饰的成员函数中被修改，如_readCount。

注意：const只能修饰非静态函数。

建议：将所有不改变对象状态的函数都使用const修饰符修饰，以提高程序的可读性。其实，**头文件**就是最好的类接口的说明文档，越多的提供信息就能使程序的可读性越好，越利于维护。看**到成员函数的const修饰符**，**读者便立即明白该函数不会改变程序的状态**，这也有利于当程序状态出现异常时的问题定位。

### const修饰函数参数

很常见，表示函数的参数在函数体内不会被意外修改，一般用于修饰**输入参数**。

```c++
char* strcat(char* str1,const char* str2);
```

### const修饰函数返回值

只要返回值不是void，const就可以用来修饰。但实际上const修饰非引用的返回值类型是没有意义的，因为返回值一般都会被赋值给另一个变量，此时用于传递返回值的对象已经被销毁。

## 7. 类继承时的构造函数

**注意事项**：

子类继承的构造函数，需要准寻；

* 父类属性通过父类的构造函数初始化
* 子类中的构造函数，必须要调用父类构造函数，必须采用初始化参数列表的方式

```c++
class MM {
public:
    MM(){};
    MM(string name, int money) : name(name),money(money){};
}
class Son : public MM {	//继承父类
    Son(){};	//若子类含无参构造函数，父类必须要有一个无参的构造函数。等效于Son() : MM()
    Son(string name, int money, int age) : MM(name,money){
        this->age = age;
    }//自己的属性怎样初始化都行，但父类中继承下来的属性，必须调用父类的构造函数初始化。
}
```

* 对于继承多个父类的情况，首先，按照父类在继承声明时的次序调用对应的构造函数；
* 其次，按照子类的对象成员在子类中声明次序对其进行初始化；
* 最后，执行子类构造函数体。

```c++
class Point: public X, public Y,public Z{
public:
	Point(int val_x, int val_y,int val_point) : X(val_x),Y(val_y)
}
```

在调用构造函数时，是先调用父类的构造函数，再是子类的构造函数。子类对象的释放过程则是恰恰相反。

## 8. 结构体与类

C++中，结构体与类区别不是很大，可以说结构体就是类，也包含构造函数和析构函数！！！

二者区别：

* struct默认是public；class默认是private。
* 从内存分配上，struct变量放在栈上，class变量放到堆上。因此struct变量会自动释放，而class变量需要手动释放。

## 9. 虚函数

在基类中使用，以`virtual`声明，告诉编译器不要静态链接到该函数。

```c++
virtual int area() = 0;	//=0告诉编译器，函数没有主体，此为纯虚函数
```

## 10. 接口类

接口是一系列抽象方法的声明，这些方法都是抽象的：

* 接口类中不能声明成员变量、静态变量；

* 可以声明静态常量作为接口的返回值状态，但需要在对应的cpp中定义并初始化。访问时使用"接口类::静态常量名"访问；

* 定义接口的方法都是纯虚的-->virtual修饰和"=0"修饰。

  ```c++
  class IShape{
  public:
  	virtual int size() = 0;
  	static const int MIN_SIZE;
  };
  //IShape.cpp文件
  const int IShape::MIN_SIZE = 0;	//对应cpp文件中定义并初始化
  ```

* 由于接口类是无法创建对象的，因此不应该编写构造函数和析构函数！！！

```c++
class Rectangle : public IShape ,public IAction {	//可以实现承多个接口
 public:
    int size() override; 
public:
    void run() override;
};
```



## 11. 异常处理

```c++
try{
    func1()...;
    	throw ".....condition";
}catch(ExceptionName e){		//catch(const char* msg),throw的是char*类型
    
}
```

C++提供了一系列标准异常，定义在`<exception>`中：

![C++ 异常的层次结构]({{site.baseurl}}/pictures/基本语法补充.assets/exceptions_in_cpp.png)

### 定义异常

通过继承和重载exception类来定义新的异常

```c++
#include <exception>
#include <iostream>
struct MyException : public exception
{
    const char* what() const throw()
    {
        return "C++ Exception";
    }
};
int main(){
    try{
        throw MyException();
    }catch(MyException& e){
        std::cout<<e.what()<<std::endl;
    }catch(std::exception& e){
        //其它错误
    }
}
```

## 12. 模板

### 函数模板

格式：

```c++
template <typename type> ret-type func-name(parameter list){
    //函数主体
}
```

```c++
templete <typename T>
inline T const& Max(T const& a, T const& b){
	return a < b ? b : a;
}
int main(){
    int i = 10;int j = 20;
    std::cout << Max(i,j)<<std::endl;
    string s1 = "add"; string s2 = "adc";
    std::cout << Max(s1,s2) <<std::endl;
}
```



### 类模板

```c++
template <class type> class class-name{
}
//type是占位符类型名称，可以在类被实例化时进行指定，可以使用逗号分割的列表来定义多个泛型数据类型
```

```c++
template <class T>
class Stack{
	private:
    	vector<T> elems;
    public:
    	void push(T const&);
    	T top() const;
};

template <class T>
void Stack<T>::push(T const& elem){
    elems.push_back(elem);
}
template <class T>
T Stack<T>::top() const{
    return elems.back();
}
```

## 13. 命名空间

```c++
using namesapce std;	
```

这叫做using编译指令。

命名空间是为了组织大型程序中不同代码模块中，存在函数名相同的函数，比如都叫wanda(),这样编译器就不知道指的是哪个版本了。因此采样命名空间就可以区分不同版本。

Microflop公司的叫Microflop::wanda();Piscine公司的叫Piscine::wanda()。

上面这种是一个偷懒的做法，更建议指定使用其中对应的函数，如：

```c++
using std::cout;
using std::endl;
```

* 此外，处理typedef，using也可用于模板别名：

  ```c++
  template<typename T>
  using arr12 = std::array<T,12>;		//将参数int设置为12
  using itType = std::vector<std::string>::iterator;
  //这样就可以直接使用别名了，用法与typedef一样
  arr12<double> a1;
  ```

  

## 14. 符号常量（最大值、最小值）

部分常量说明：

| 符号常量  | 表示                  |
| --------- | --------------------- |
| CHAR_BIT  | char的位数            |
| CHAR_MAX  | char的最小值          |
| CHAR_MIN  | char的最大值          |
| SCHAR_MIN | signed char最小值     |
| UCHAR_MAX | unsigned char最大值   |
| SHRT_MIN  | short的最小值         |
| INT_MAX   | int的最大值           |
| LONG_MIN  | long的最小值          |
| ULONG_MAX | unsigned long的最大值 |
| LLONG_MIN | long long的最小值     |

## 15. C++11新增初始化方式

这种新增初始化方式，适用于数组和结构，也可用于单值变量。

* ```c++
  int hamburgers = {24};		//设置hamburgers为24
  ```

* ```c++
  int emus{7};		//另一种初始化方式，设置enum为5
  ```

* ```c++
  int rocs{};或 int psp = {};		//{}不包含内容，则默认初始化为0
  int arr[10]{};或 int arr[10] = {};	//初始化填充0
  ```

  注意，不仅仅是变量，等号都可以省略

## 16. 结构体

有一点需要注意，C++的struct声明结构体变量时，可以直接省略struct了，这是与C语言的不同之处。

### 结构体初始化

```c++
struct inflatable {
	char name[20];
	float volume;
	double price;
};
inflatable vincent;		//声明变量新方式
inflatable guest = {	//初始化方式1，与数组一样，采样','分割
    "Glorious Glor",
    1.88,
    29.99
};			
inflatable duck = {"Daphne",0.12,9.98};	//也可以放到一行进行初始化
inflatable duck {"Daphne",0.12,9.98};	//C++11可以省略=。
inflatable mayor {};					//初始化各个参数都为0，name的每个字节也都被设置为0.
```

### 结构体位字段

字段类型应为整形或枚举，接下来是冒号，最后是指定的位数。

```c++
struct torgle_register {
    unsigned int SN : 4;		//4 bit for SN
    unsigned int : 4;			//4 bit unused;
    bool goodIn : 1;			//1 bit 
    bool goodTorgle : 1;		//1 bit 返回值
}
```

一般可以使用位运算替代这种方式。

### 结构体数组

定义：

```c++
class StructTest{
public:
	struct cpu_info{
      	int freq;
		...
    };
    void getCPUInfo(cpu_info cpuInfo[]);	//数组方式调用
    void getCPUInfo(cpu_info* cpuInfo, int size);	//指针方式调用，提供数量
    void getCPUInfo(cpu_info* cpuInfo);	//仅指针方式调用
    void getCPUInfo(cpu_info (&cpuInfo)[4]);	//以引用的方式传参，注意括号必须要有，而且注意界限，缺一不可
}
//调用函数
{
    StructTest::cpu_info cpuInfo[4];	//声明
    StructTest test;
    test.getCPUInfo(cpuInfo);
}
```

结构体数组作为函数参数传递的方式：

* 数组的方式：fun(Person people[])  # 数组内可以指定长度，也可以缺省，没有任何影响。
* 指针的方式：fun(Person* people,int size);  可以指定数组长度，也可以不指定
* 引用的方式：fun(Person (&people)[]);  必须加括号

### 结构体定义

结构体内部不能包含自己，可以包含一个指向自己结构体的指针：

```c++
struct A{
    char a[10];
    struct A* a;	//这是可以的
    struct A a;		//错误的
    struct B b;		//可以包含其它结构体
}
```

内存对齐：占用16个字节，而不是1+4+8

![结构体大小]({{site.baseurl}}/pictures/基本语法补充.assets/dd7b10b431554d378f8dd37d37e604b9.png)

## 17. vector容器

vector容器是标准库中一种常见的容器，可以用来代替c++原来的数组。

数组只能实现一对一的映射，而不能实现一对多映射，vector就是为了解决这个问题。

### vector初始化

`vector<T>`

vector作为存放一串数据的容器，在创建和初始化时就要考虑**数据类型**、**数据的个数**以及**数据的值**：`vector<存储的类型> 容器名`

```c++
#include <iostream>
#include <vector>	//是标准库中的类，因此需要包含<vector>
int main(){
    vector<int> vec1;
    vector<float> vec2(3);	//定义了一个有3个元素，没有初始化
    vector<char> vec3<3,'a');	//含有3个‘a'的字符vector，括号第2个元素代表所有元素的指定值
    vector<char> vec4<vec3>;	//通过拷贝vec3来初始化vec4
    vector<string> vec5;	//字符串型
    vector<结构体名> v;		//结构体型
    vector<double> vec[n]	//vector数组，n为数组大小
    return 0;
}
```

### 分配空间

当vector声明以后，因为没有元素，因此没有分配空间。当添加第一个元素时，会自动分配内存。可以通过以下操作增加容器的容量：

```c++
std::vector<int> queue;
queue.reserve(20);		//内存分配，至少可以容纳20个元素；
//如果queue本身大小大于20，则该语句什么都不做。
```

**注意：**采用reserve()来增加内存，会导致任何现有的迭代器失效。因为为了增加容量，容器内的元素可以已经被复制或移动到新的内存地址了。

```c++
queue.resize(20);	//同样可以调整大小
queue.resize(20,-1);	//重新调整大小为20，并存储20个-1元素，如果本身内部有元素，则只会填充空余部分为-1.
```

* resize()可以调整大小
* resize()可以在调整大小的同时，进行内容填充，reserve()不可以。

### vector操作

1. 遍历

```c++
for(int i = 0; i < vec3.size(); i++){
	cout<<vec3[i]<<" ";
}
```

2. 添加元素

```c++
if(vec1.empty()){
	cout<<"Empty";
}
vec1.push_back(1);
vec1.push_back(2);
cout<<vec1[0]<<" "<<vec1[1];
```

3. 移除元素

```c++
vector vec1<int>(3,2);
vec1.pop_back();
vec1.clear();	//清除全部元素
```

`push_back()`与`pop_back()`一样，都是从vector末尾进行尾操作。需要注意的是，如果vector为空，再进行`pop_back()`操作，会产生异常，因此**需要结合`empty()`进行判定控制**。

4. 插入元素

```c++
vector vec1<int>(3,2);		//初始化3个2
vector <int>::iterator theIterator = vec1.begin();	//迭代器,用来指定位置
vec1.insert(theInterator,1,22);		//在迭代器指定位置前插入1个值为22的元素
for(int i = 0; i < vec1.size(); i++){
	cout<<vec1[i]<<" ";
}
//begin()返回头部迭代器
//end()返回尾部+1迭代器
//front()返回首个元素	//其实通过vec[0]、vec[vec.size()-1]一样，不过front显得专业
//back()返回尾部元素
//erase()在指定位置删除元素
//clear()清除容器
```

因为插入操作，会导致后面的元素都要后移，时间复杂度O(n);而增删时间复杂度只有O(1)。尽量少用insert()。erase()时间复杂度同样高，减少使用。

```
insert (position, x );
insert (position, n, x );
insert (position, first, last );
插入新的元素，
第一个函数，在迭代器指定的位置前插入值为x的元素
第二个函数，在迭代器指定的位置前插入n个值为x的元素
第三个函数，在迭代器指定的位置前插入另外一个容器的一段序列迭代器first到last
erase ( position );
erase (first, last );
删除元素或一段序列
```

4. 相等判断与赋值

```c++
vector<int> vec1(3,2);
vector<int> vec2;
vec2 = vec1;
if(vec2 == vec1){
	cout<<"赋值成功";
}
```

注意：vector赋值，会将所有元素赋值到另一个vector中，并替代所有元素；而相等判断也是逐个元素依次进行比较，只有全部相等才算相等。

### 数据类型转化

1. string转vector

```c++
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;
int main(){
    string str = "hello";
    vector<char> vec;
    vec.assign(str.begin(),str.end());
    //打印输出
}
```

2. vector转string

```c++
//常规方法
string str;
for(int i = 0; i < vec.size(); i++){
    str += vec[i];
}
str+='\0';

//方法2
const char* s = &(vec.begin());
str = std::string(s,vec.size());
//方法3
string str2;
vector<string> vec2{"hhh","zzz"};
str2 = accumulate(vec2.begin(),vec2.end(),str2);
```

### 传递参数

==**特别注意**：vector传参，如果要想通过形参影响到实参：==

* void func(vector &vet);	//引用
* void func(vector *vet);     //指针

==仅传递数值方式不会影响到实参==

* void func(vector vet);  //数据需要进行拷贝，数据量大时耗时。

==最好采用**引用**或指针进行传参==

## 18. string类

与常规容器接口基本相同，再添加了一些转门用来操作string的常规操作。

### 初始化

```c++
string a = "abc";
string b(a,1,2);	//从a字符串1的位置复制2个字符bc
string c("abc",1,2);//同上，bc
string d(8,'k');	//用8个k初始化
```

### 操作函数

| 函数名称                       | 功能说明                               |
| ------------------------------ | -------------------------------------- |
| size_t size() const            | 返回字符串有效字符长度                 |
| size_t length() const          | 同上                                   |
| size_t capacity() const        | 返回空间总大小                         |
| bool empty() const             | 是否空串                               |
| void clear()                   | 清空                                   |
| void resize(size_t n, char c)  | 将有效字符个数改成n，空余空间字符c填充 |
| void resize(size_t n)          | 同上，多出空间用0填充                  |
| void reserve(size_t res_arg=0) | 为字符串预留空间                       |

* reserve()一般与插入、操作符+=配合，它只是扩充容量，size仍为原大小（即未填充任何数据）
* resize()一般与操作符[]配合使用，这样即扩容，又改变了size()大小，可以通过[]直接访问。

| 函数名称                                         | 功能说明                                   |
| ------------------------------------------------ | ------------------------------------------ |
| void push_back(char c)                           | 在字符串后插字符c                          |
| string& append(const char* s)                    | 在字符串后追加一个字符串                   |
| const char* c_str() const                        | 返回C格式字符串                            |
| size_t find(char c, size_t pos=0) const          | 从字符串pos位置开始查找c，返回c的位置      |
| size_t rfind(char c, size_t pos=0)               | 从pos位置往前找c，返回c在字符串中位置      |
| string substr(size_t pos=0, size_t n=npos) const | 从字符串pos位置，截取n个字符，然后将其返回 |
| char& operator[] (size_t pos)                    | 返回pos位置的字符                          |
| obj.at(i)                                        | 实质上是一个函数                           |

在string尾部追加字符时，push_back()/append()/+=这三种方式差不多，一般+=操作用的比较多。+=可以连接单个字符以及字符串。

* 注意，减少使用操作符+，因为其效率低。

### 大小写转化

```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main(){
	string str = "AFDScvsd";
	for(char ch : str){
		ch = toupper(ch);	//转大写
		ch = tolower(ch);	//转小写
	}
	//或者
	for(int i = 0; i < str.size(); i++){
		str[i] = toupper(s[i]);
	}
}
```

```c++
string str = "asdfsd";
cout<<strupr(str)<<endl;
```



```c++
//通过STL的transform实现
transform(str.begin(),str.end,str.begin(),::toupper);
//前4个字符小写
transform(str.begin(),str.begin()+5,str.begin(),::tolower);
```

### 空判断

注意，string类为空不能用NULL判断。

* 使用string的成员函数`empty()`来判断，这是**效率最高**也是最常用的

  ```c++
  string str;
  if(str.empty()){}
  ```

* 使用`size()`判断

  ```c++
  if(str.size() == 0){}
  ```

* 与空串`""`比较

  ```c++
  if(str == ""){}
  ```

### 类型转换

#### 其它类型转string

1. int、long、float、double转string

   * 标准库方法

   ```c++
   int n = 2023;
   string str = to_string(n);
   ```

   * 函数模板+ostringstream

     这种方法需要引入头文件，整形、浮点型均可使用

   ```c++
   template <class Type>
   string tostring(const Type& t){
       ostringstream oss;
       oss << t;
       return oss.str();
   }
   
   int n = 2023;
   string str = tostring(n);
   ```

#### string转其它类型

1. string转int型

   * C语言标准库方法

   ```c++
   string str = "2023";
   int num = atoi(str.c_str());
   ```

   * C++标准库方法`<string>`

   ```c++
   string str = "2023";
   int num = stoi(str);		
   ```

   * 函数模板方法

   ```c++
   template <class Type>
   Type stringtoNum(const string& str){
       istringstream iss(str);
       Type num;
       iss >> num;
       return num;
   }
   int num = stringtoNum<int>(str);
   ```

2. 浮点型

   ```c++
   string str = "3.1415";
   double num;
   num = atof(str.c_str(str));
   num = stod(str);		//long:stol()、float:stof()
   num = stringtoNum<double>(str);
   ```

   

### 查找字符串

1. C语言风格:`strstr(s1,s2)`返回第一次出现的位置

   ```c++
   #include <string>
   #include <cstring>
   string a = "abcdefg";
   char *b = "def";
   if(strstr(a.c_str(),b) == NULL){}	
   ```

2. C++风格:`string::size_type string::find(string &)`

   ```c++
   #include <string>
   string a = "abcdefg";
   string b = "def";
   string::size_type idx;
   idx = a.find(b);
   if(idx == string::npos)	//不存在
   else	//存在返回正确位置
   ```

### string类其它方法

* 链接字符串

    ```c++
    b.append(a);
    b.append(a,1,2);	//defbc	链接的是a的下标1开始的2个字符
    b = b + a;
    b.append(4,'a');	//defaaaa
    b.append("yuv",0,3);//defyuv “yuv"从第0个字符开始，链接3个
    ```

* 替换字符串

  ```c++
  string a = "xxxxb";
  a.replace(1,4,"ab");	//abcdb从第1个字符开始替换，总共替换4个字符
  //这是直接替换，无论替换内容是否够，不够的话直接去除
  ```
  
* 删除字符串

  ```c++
  a.erase(3);	//删除下标为3及后面的元素
  a.erase(1,4); //删除下标1~4位的元素
  ```

## 19. stringstream(流)

`#include <sstream>`

```c++
stringstream s;
//赋值
s << "afda"<<"dfd";
cout<<s.str();
//清空
s.str("");
//类型转换
int b;
stringstream a;
a << "123";
a >> b;
```

## 20. C++类型转换

C++常用的四种转换类型：

| 转换类型操作符   | 作用                                       |
| ---------------- | ------------------------------------------ |
| const_cast       | 去掉类型的const或volatile属性              |
| static_cast      | 类似C语言的无条件转换，静态类型转换        |
| dynamic_cast     | 有条件转换，运行时会检查安全，失败返回NULL |
| reinterpret_cast | 仅重写解释类型，但并没有进行二进制转换     |

1) `const_cast<目标类型>(标识符)`:目标类型只能是指针或引用；

2. static_cast可以进行转换：

* 基类与子类：将子类指针转换为父类指针是安全的，反之则是不安全的。（基类与子类之间的转换，最好使用dynamic_cast。
* 基本数据类型转换，包括enum、struct、int...
* 把任何类型的表达式转换成void类型。

3. dynamic_cast为动态类型转换，具有类型检查的功能，比static_cast安全。

* 转换指针失败，返回null，成功返回正常转换后的对象指针；
* 转换引用失败，会抛出一个异常，成功返回正常的对象引用

## 21. `<algorithm>`库

### reverse反转

* reverse用于反转在范围[first,last）范围内的元素，注意，不包括last位置的元素。

  ```c++
  vector<int> num{1,2,3,4,5};
  reverse(num.begin(),num.end());
  string str = "afas";
  reverse(str.begin(),str.end());
  ```


### sort()

本质是一个模板函数，对普通数组或容器中指定范围的元素进行排序。

```c++
sort(first, last);	//[first,last)，first和last都为随机迭代器
stable_sort(first,last);	//不改变相同元素的相对位置
is_sorted(first,last);		//是否已排好序，默认升序判断
```

* 若为自定义类的对象，改类内部需提供移动构造函数和移动赋值运算符

## std::function

是一个函数包装模板，类似于函数指针，不过相比指针调用函数更方便。

可以包装：

* 函数

* 函数指针

* 类成员函数指针

* 其它任意类型的函数对象

  `<返回类型(参数1数据类型/形参，参数2数据类型/形参)>`

  ```c++
  template<class R, class ... Args>
  class function<R(Args...)>;	//R:被调函数返回类型；Args：被调函数的形参
  ```

  

```c++
//1.包装普通函数
#include <functional>
int g_Minus(int i, int j) {
    return i - j;
}
function<int(int,int)> f = g_Minus;
cout<< f(1,2);			//输出结果都是-1
//2.包装模板函数
template <class T>
T g_Minus(T i, T j) {
    return i - j;
}
function<int(int,int)> f = g_Minus<int>;
//3.通过bind调用类成员函数
class Math {
public:
    template <class T>
    T Minus(T i, T j) {
        return i - j;
    }
};
Math m;
function<int(int,int)> f1 = bind(&Math::Minus<int>, &m, placeholders::_1, placeholder::_2); //placeholder::_1是占位符
function<int(int,int)> f2 = bind(&Math::Minus<int>, m, placeholders::_1, placeholder::_2);	//以对象的形式调用成员函数
```



## 其它

1. 注意按位左移或者右移，**右移1位便是除以2**了，不要弄多了。

2. 指针判断

特别是双指针判断，快慢双指针判断时，一定要注意判断指针是否为空的先后顺序问题！

```c++
ListNode* middleNode(ListNode *head){
	struct ListNode *pfast = head;		//容易忽略的点，没有使用typedef定义的结构体，在生成对象时，注意加上struct。(暂时C++不确定)
	struct ListNode *pslow = head;
	while(pfast != NULL && pfast->next != NULL){	//注意此处，与判断是按照先后顺序来执行的，如果pfast->next在前，就会因为pfast不存在下一个指向对象而保错。
        pfast = pfast->next->next;
        pslow = pslow->next;
    }
    return pslow;
}
```

3. NULL与nullptr

   c++11增加了nullptr，保证在任何情况下都表示空指针，因此尽量采用nullptr

4. 结构体
   * `struct A *b`:只是定义了一个指针，其空间大小就是一个指针所占用的字节，比如32位系统上，其大小就是4字节。
   * `struct A c`：定义了一个struct A对象，需要分配存储空间

5. for循环中的自增

   ```c++
   for(n = lim; n > 0; --n)
   for(n = lim; n > 0; n--)
   ```

   这两种结果是一样的，但是，前缀版本的效率比后缀版本高。前缀函数：将值加1，然后返回结果；后缀函数：先复制一个副本，将其加1，在将复制的副本返回。因此，对于类而言，前缀版本的效率比后缀版本高。

   ```c++
   x++;
   ++x;
   ```

   这种是完整的表达式，自增操作执行完后才进入下一步操作，因此最终效果是相同的；

   暂时还没有搞清除效率问题。

6. 注意引用与指针的区别

   引用只是变量的别名，传递对象的引用，那么对象始终只有一份，只是存在多个别名而已。指针是一块内存指向另一块内存，指针侧重于“指向”二字，而引用是只有一块内存，存在多个别名。别名与其本体侧重于“一体”二字，引用就是本体，本体就是引用，根本不存在“指向”关系。

7. this

   this就是一个指针，谁调用的这个结构，this就指代谁，如：

   ```c++
   add(this,b) ...
   num1.add(b); //this就是num1，编译器编译时会自动将this替换为num1.
   ```

   一般定义函数参数时，不需要指定this了，直接在函数内部使用即可。
